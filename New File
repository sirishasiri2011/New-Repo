void FindChildNodes(dynamic obj, dynamic coreEntity, dynamic mainEntityId)
{
    List<dynamic> childNodes = new List<dynamic>();
    if (obj != null)
    {
        foreach (var el in obj)
        {
            var element = el?.entityOwners?.FirstOrDefault(x => x.ownerId == coreEntity.coreEntityId);
            if (element != null)
            {
                if (!this.entOwnerRefMap[mainEntityId].childNodes.Any(x => x.coreEntityId == el.coreEntityId))
                {
                    this.entOwnerRefMap[mainEntityId].childNodes.Add(new { coreEntityId = el.coreEntityId, entityName = el.entityName });
                }
                childNodes.Add(new { coreEntityId = el.coreEntityId, entityName = el.entityName });
                foreach (var ch in childNodes)
                {
                    FindChildNodes(obj, ch, mainEntityId);
                }
            }
        }
    }
}

public dynamic CheckCircularReferenceOnAdditionalOwners()
{
    bool circularRefFound = false;
    string circularSequence = "";
    List<string> sequence = new List<string>();
    foreach (var item in circRefCheckMap)
    {
        var result = item.Value.ChildNodes.Where(o => item.Value.OwnerNodes.Any(x => o.CoreEntityId == x.CoreEntityId)).ToList();
        if (result.Count > 0)
        {
            circularRefFound = true;
            sequence = new List<string> { item.Value.EntityName }.Concat(result.Select(v => v.EntityName)).Concat(new List<string> { item.Value.EntityName }).ToList();
        }
    }
    if (circularRefFound)
    {
        circularSequence = string.Join(" -> ", sequence);
        return circularSequence;
    }
    else
    {
        return new List<string>();
    }
}


    checkCircularReferenceOnAdditionalOwners(): any {  
        let circularRefFound = false;
        let circularSequence: string = '';
        let sequence = [];
        this.circRefCheckMap.forEach(item => {
            let result = item.childNodes.filter(o => item.ownerNodes.some(({coreEntityId}) => o.coreEntityId === coreEntityId));
            if(result.length > 0) {                 
                circularRefFound = true;
                sequence = [... [item.entityName], ... result?.map(v => v.entityName), ...[item.entityName]];
            }
        });

        if(circularRefFound) {
            circularSequence = sequence.join(' -> ');
            return circularSequence;
        } else {
            return [];
        }
    }

    findChildNodes(obj: any, coreEntity: any, mainEntityId: any): void {
        let childNodes = [];
        obj?.forEach(el => {
            let element = el?.entityOwners?.find(x => x.ownerId === coreEntity.coreEntityId);
            if(element) { 
                if(!this.entOwnerRefMap[mainEntityId].childNodes.some(x => x.coreEntityId === el.coreEntityId)) { 
                    this.entOwnerRefMap[mainEntityId].childNodes.push({coreEntityId: el.coreEntityId, entityName: el.entityName});         
                }              
                childNodes.push({coreEntityId: el.coreEntityId, entityName: el.entityName});         
                childNodes?.forEach(ch => {
                    this.findChildNodes(obj, ch, mainEntityId);
                })
            }
        })
